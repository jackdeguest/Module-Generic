.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Module::Generic 3"
.TH Module::Generic 3 "2019-08-28" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Module::Generic \- Generic Module to inherit from
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&    package MyModule;
\&    BEGIN
\&    {
\&        use strict;
\&        use Module::Generic;
\&        our( @ISA ) = qw( Module::Generic );
\&    };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Module::Generic\*(C'\fR as its name says it all, is a generic module to inherit from.
It contains standard methods that may howerver be bypassed by the module using 
\&\f(CW\*(C`Module::Generic\*(C'\fR.
.PP
As an added benefit, it also contains a powerfull \s-1AUTOLOAD\s0 transforming any hash 
object key into dynamic methods and also recognize the dynamic routine a la AutoLoader
from which I have shamelessly copied in the \s-1AUTOLOAD\s0 code. The reason is that while
\&\f(CW\*(C`AutoLoader\*(C'\fR provides the user with a convenient \s-1AUTOLOAD, I\s0 wanted a way to also
keep the functionnality of \f(CW\*(C`Module::Generic\*(C'\fR \s-1AUTOLOAD\s0 that were not included in
\&\f(CW\*(C`AutoLoader\*(C'\fR. So the only solution was a merger.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBimport\fR()" 4
.IX Item "import()"
\&\fBimport\fR() is used for the AutoLoader mechanism and hence is not a public method.
It is just mentionned here for info only.
.IP "\fBnew\fR()" 4
.IX Item "new()"
\&\fBnew\fR() will create a new object for the package, pass any argument it might receive
to the special standard routine \fBinit\fR that \fImust\fR exist. 
Then it returns what returns \fBinit\fR().
.Sp
To protect object inner content from sneaking by thrid party, you can declare the 
package global variable \fI\s-1OBJECT_PERMS\s0\fR and give it a Unix permission.
It will then work just like Unix permission. That is, if permission is 700, then only the 
module who generated the object may read/write content of the object. However, if
you set 755, the, other may look into the content of the object, but may not modify it.
777, as you would have guessed, allow other to modify the content of an object.
If \fI\s-1OBJECT_PERMS\s0\fR is not defined, permissions system is not activated and hence anyone 
may access and possibibly modify the content of your object.
.Sp
If the module runs under mod_perl, it is recognized and a clean up registered routine is 
declared to Apache to clean up the content of the object.
.IP "\fBclear_error\fR" 4
.IX Item "clear_error"
Clear all error from the object and from the available global variable \f(CW$ERROR\fR.
.Sp
This is a handy method to use at the beginning of other methods of calling package,
so the end user may do a test such as:
.Sp
.Vb 2
\&    $obj\->some_method( \*(Aqsome arguments\*(Aq );
\&    die( $obj\->error() ) if( $obj\->error() );
\&
\&    ## some_method() would then contain something like:
\&    sub some_method
\&    {
\&        my $self = shift( @_ );
\&        ## Clear all previous error, so we may set our own later one eventually
\&        $self\->clear_error();
\&        ## ...
\&    }
.Ve
.Sp
This way the end user may be sure that if \f(CW\*(C`$obj\-\*(C'\fR\fBerror()\fR> returns true something
wrong has occured.
.IP "\fBerror\fR()" 4
.IX Item "error()"
Set the current error, do a warn on it and returns \fBundef()\fR:
.Sp
.Vb 4
\&    if( $some_condition )
\&    {
\&        return( $self\->error( "Some error." ) );
\&    }
.Ve
.Sp
Note that you do not have to worry about a trailing line feed sequence.
\&\fBerror\fR() takes care of it.
.Sp
Note also that by calling \fBerror\fR() it will not clear the current error. For that
you have to call \fBclear_error\fR() explicitly.
.Sp
Also, when an error is set, the global variable \fI\s-1ERROR\s0\fR is set accordingly. This is
especially usefull, when your initiating an object and that an error occured. At that
time, since the object could not be initiated, the end user can not use the object to 
get the error message, and then can get it using the global module variable 
\&\fI\s-1ERROR\s0\fR, for example:
.Sp
.Vb 2
\&    my $obj = Some::Package\->new ||
\&    die( $Some::Package::ERROR, "\en" );
.Ve
.IP "\fBerrors\fR()" 4
.IX Item "errors()"
Used by \fBerror\fR() to store the error sent to him for history.
.Sp
It returns an array of all error that have occured in lsit context, and the last 
error in scalar context.
.IP "\fBerrstr\fR()" 4
.IX Item "errstr()"
Set/get the error string, period. It does not produce any warning like \fBerror\fR would do.
.IP "\fBget\fR()" 4
.IX Item "get()"
Uset to get an object data key value:
.Sp
.Vb 5
\&    $obj\->set( \*(Aqverbose\*(Aq => 1, \*(Aqdebug\*(Aq => 0 );
\&    ## ...
\&    my $verbose = $obj\->get( \*(Aqverbose\*(Aq );
\&    my @vals = $obj\->get( qw( verbose debug ) );
\&    print( $out "Verbose level is $vals[ 0 ] and debug level is $vals[ 1 ]\en" );
.Ve
.Sp
This is no more needed, as it has been more conveniently bypassed by the \s-1AUTOLOAD\s0
generic routine with chich you may say:
.Sp
.Vb 4
\&    $obj\->verbose( 1 );
\&    $obj\->debug( 0 );
\&    ## ...
\&    my $verbose = $obj\->verbose();
.Ve
.Sp
Much better, no?
.IP "\fBinit\fR()" 4
.IX Item "init()"
This is the \fBnew\fR() package object initializer. It is called by \fBnew\fR()
and is used to set up any parameter provided in a hash like fashion:
.Sp
.Vb 1
\&    my $obj My::Module\->new( \*(Aqverbose\*(Aq => 1, \*(Aqdebug\*(Aq => 0 );
.Ve
.Sp
You may want to superseed \fBinit\fR() to have suit your needs.
.Sp
\&\fBinit\fR() needs to returns the object it received in the first place or an error if
something went wrong, such as:
.Sp
.Vb 8
\&    sub init
\&    {
\&        my $self = shift( @_ );
\&        my $dbh  = DB::Object\->connect() ||
\&        return( $self\->error( "Unable to connect to database server." ) );
\&        $self\->{ \*(Aqdbh\*(Aq } = $dbh;
\&        return( $self );
\&    }
.Ve
.Sp
In this example, using \fBerror\fR will set the global variable \f(CW$ERROR\fR that will
contain the error, so user can say:
.Sp
.Vb 1
\&    my $obj = My::Module\->new() || die( $My::Module::ERROR );
.Ve
.Sp
If the global variable \fI\s-1VERBOSE\s0\fR, \fI\s-1DEBUG\s0\fR, \fI\s-1VERSION\s0\fR are defined in the module,
and that they do not exist as an object key, they will be set automatically and
accordingly to those global variable.
.Sp
The supported data type of the object generated by the \fBnew\fR method may either be
a hash reference or a glob reference. Those supported data types may very well be
extended to an array reference in a near future.
.IP "\fBmessage\fR()" 4
.IX Item "message()"
\&\fBmessage\fR() is used to display verbose/debug output. It will display something
to the extend that either \fIverbose\fR or \fIdebug\fR are toggled on.
.Sp
If so, all debugging message will be prepended by \f(CW\*(C`## \*(C'\fR to highlight the fact
that this is a debugging message.
.Sp
Addionally, if a number is provided as first argument to \fBmessage\fR(), it will be 
treated as the minimum required level of debugness. So, if the current debug
state level is not equal or superior to the one provided as first argument, the
message will not be displayed.
.Sp
For example:
.Sp
.Vb 6
\&    ## Set debugness to 3
\&    $obj\->debug( 3 );
\&    ## This message will not be printed
\&    $obj\->message( 4, "Some detailed debugging stuff that we might not want." );
\&    ## This will be displayed
\&    $obj\->message( 2, "Some more common message we want the user to see." );
.Ve
.Sp
Now, why debug is used and not verbose level? Well, because mostly, the verbose level
needs only to be true, that is equal to 1 to be efficient. You do not really need to have
a verbose level greater than 1. However, the debug level usually may have various level.
.IP "\fBset\fR()" 4
.IX Item "set()"
\&\fBset\fR() sets object inner data type and takes arguments in a hash like fashion:
.Sp
.Vb 1
\&    $obj\->set( \*(Aqverbose\*(Aq => 1, \*(Aqdebug\*(Aq => 0 );
.Ve
.IP "\fBsubclasses\fR( [ \s-1CLASS\s0 ] )" 4
.IX Item "subclasses( [ CLASS ] )"
This method try to guess all the existing sub classes of the provided \fI\s-1CLASS\s0\fR.
.Sp
If \fI\s-1CLASS\s0\fR is not provided, the class into which was blessed the calling object will
be used instead.
.Sp
It returns an array of subclasses in list context and a reference to an array of those
subclasses in scalar context.
.Sp
If an error occured, undef is returned and an error is set accordingly. The latter can
be retrieved using the \fBerror\fR method.
.IP "\fB\s-1AUTOLOAD\s0\fR" 4
.IX Item "AUTOLOAD"
The special \fB\s-1AUTOLOAD\s0\fR() routine is called by perl when no mathing routine was found
in the module.
.Sp
\&\fB\s-1AUTOLOAD\s0\fR() will then try hard to process the request.
For example, let's assue we have a routine \fBfoo\fR.
.Sp
It will first, check if an equivalent entry of the routine name that was called exist in
the hash reference of the object. If there is and that more than one argument were
passed to this non existing routine, those arguments will be stored as a reference to an
array as a value of the key in the object. Otherwise the single argument will simply be stored
as the value of the key of the object.
.Sp
Then, if called in list context, it will return a array if the value of the key entry was an array
reference, or a hash list if the value of the key entry was a hash reference, or finally the value
of the key entry.
.Sp
If this non existing routine that was called is actually defined, the routine will be redeclared and
the arguments passed to it.
.Sp
If this fails too, it will try to check for an AutoLoadable file in \f(CW\*(C`auto/PackageName/routine_name.al\*(C'\fR
.Sp
If the filed exists, it will be required, the routine name linked into the package name space and finally
called with the arguments.
.Sp
If the require process failed or if the AutoLoadable routine file did not exist, \fB\s-1AUTOLOAD\s0\fR() will
check if the special routine \fB\s-1EXTRA_AUTOLOAD\s0\fR() exists in the module. If it does, it will call it and pass
it the arguments. Otherwise, \fB\s-1AUTOLOAD\s0\fR will die with a message explaining that the called routine did 
not exist and could not be found in the current class.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2000\-2014 \s-1DEGUEST\s0 Pte. Ltd.
.SH "CREDITS"
.IX Header "CREDITS"
Jacques Deguest <\fIjack@deguest.jp\fR>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
